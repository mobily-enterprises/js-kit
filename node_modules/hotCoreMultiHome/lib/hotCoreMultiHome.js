"use strict";

/**
Provides multi-home abilities to Hotplate

This module's aim is to make sure Hotplate has full multi-home abilities. The module itself:

* Defines all of the relevant stores ( `workspaces`, `workspacesUsers`, `usersWorkspaces`)
* Places important variables on the rendered page ( `vars.hotCoreMultiHome.enabled` and `.multiHomeURL`)
* Places the crucial `vars.hotCoreMultiHome.workspaceId` variable on the rendered page

However, given the nature of this module, there are _several_ other modules in Hotplate that interact with it.

## SUMMARY: modules that deal with multihome environments:

* hotCoreJsonRestStores -- it will broadcast comet messages only to workspace users
* hotCoreStoreConfig -- if the url has `:workspaceId`, it will set config stores' records in the page for that workspace
* hotDojoGlobals -- will set global variable workspaceId if it's set within the page
* hotDojoStoreConfig -- will call `stores()` passing `userId` and `workspaceId` in resolution hash, allowing easy workspace-bound setting lists
* hotDojoAppContainer -- fully multi-home aware, will hook to correct URL and, if `:workspaceId` is in the URL, it will check that it exists.
* hotDojoAuth -- fully multi-home aware, providing a pick mechanism etc. Gets the workspace URL from `vars.hotCoreMultiHome.multiHomeURL` 

* hotDojoComet -- will add header `X-hotplate-workspaceId` to tab messages requests
* hotCoreComet -- will use `X-hotplate-workspaceId` to return updated config records for the expired workspace

A more detailed explanation of what each module does, in terms of interaction with hotCoreMultiHome, follows. Note that any interaction happens on the basis that `hotCoreMultiHome` is enabled.

## hotCoreJsonRestStores

* ./node_modules/hotCoreJsonRestStores/lib/hotCoreJsonRestStores.js

When broadcasting changes to stores via the hook `cometBroadcast`, it will change its behavious depending on multi-home being enabled or not.

If multiHome is enabled, checks if the record has a workspaceId field -- in which case, it will only broadcast the message to users in that workspaceId (it will do so by passing a `makeTabIdHash()` function to the `cometBroadcast` hook) 

## hotCoreStoreConfig

* ./node_modules/hotCoreStoreConfig/lib/hotCoreStoreConfig.js

Implements `pageElementsPerPage` that passes `params.workspaceId` to `getConfig()` -- which means that if the URL has the `workspaceId` parameter, it will add a variable with the workspace's configuration to the page. It also passes `session.userId` to `getConfig()`, so if the user is logged in, it will return that user's config too.

NOTE: `getConfig()` is implemented here. Signature: `function( workspaceId, userId, cb )`. It basically will return all configs with `workspaceId` and/or `userId` set in their `store.configStore` property

## hotDojoGlobals

* ./node_modules/hotDojoGlobals/client/globals.js

Sets the global variable `workspaceId` based on `vars.hotCoreMultiHome.workspaceId` (Unrelated: it also sets `userId` based in `vars.hotCoreAuth.userId`)

## hotDojoStoreConfig

* ./node_modules/hotDojoStoreConfig/client/ConfigVars.js

Config variables are bound to "nothing" (system-wide settings), to a user (user-wide settings), to a workspace (workspace-wide settings) or both (user-specific settings for a specific workspace). That's why ConfigVars will call `stores()` passing `:userId` and :`workspaceId` in resolution hash.

Note that `:workspaceId` and `userId` are the ONLY parameters allowed in a config store URL.


## hotDojoAppContainer

* ./node_modules/hotDojoAppContainer/lib/hotDojoAppContainer.js

In terms of URLs, it will attach to `hotCoreMultiHome.multiHomeURL` or `hotCoreAuth.appURL` depending on multi-home being enabled or not. Also, IF `:workspaceId` is in the URL as a parameter, it will check that the workspace actually exists or it will return an error.

## hotDojoAuth

* ./node_modules/hotDojoAuth/lib/hotDojoAuth.js

The pagePick callback is there just for multi-home environments, picking the workspace

* ./node_modules/hotDojoAuth/client/NewWorkspace.js

After adding a new workspace, it will redirect to it thanks to `vars.hotCoreMultiHome.multiHomeURL` (replacing `:workspaceId` with the id of the record that was just created) 

* ./node_modules/hotDojoAuth/client/Pick.js

After picking a workspace, it will redirect to it thanks to `vars.hotCoreMultiHome.multiHomeURL` as above

* ./node_modules/hotDojoStoreConfig/client/ConfigVars.js

## hotDojoComet

* ./node_modules/hotDojoComet/client/messages.js

It adds a header `X-hotplate-workspaceId` to tabId requests. This is ESSENTIAL so that hotCoreComet knows which workspaceId the tab belongs to. Yes, IT NEEDS to know it: if the tab is not found or it's expired, hotCoreComet will return only one message, `resetStores`, which will INCLUDE all configuration records for that user and workspace (in order to save GETs and implement error management app-side).

## hotCoreComet

* ./node_modules/hotCoreComet/lib/hotCoreComet.js

Uses the header `X-hotplate-workspaceId` to return the config stores' records for that `workspaceId` in case the tab is expired or not there

@module hotCoreMultiHome
@main hotCoreMultiHome
@class hotCoreMultiHome
@static
*/

var dummy
  , hotplate = require('hotplate')

  , declare = require('simpledeclare')
  , JsonRestStore = require('jsonreststores')
  , SimpleSchema = require('simpleschema')

  , hotCoreJsonRestStores = require( 'hotCoreJsonRestStores' )
  , hotCoreStoreRegistry = require( 'hotCoreStoreRegistry' )
;

var stores = {};

// Some sane defaults

// Multihome enabled
hotplate.config.set('hotCoreMultiHome', {
   enabled: true,
   multiHomeURL: '/wssssssssssssssssssss/:workspaceId', // MUST contain :workspaceId
   escapePick: true,
});




/*


  * IF workspaceId is there: return list of tabs belonging to users in that workspace
  * ELSE: return list of tabs belonging to users in workspaces common to requesting userId
  * 
*/
exports.makeTabIdHashForMultihome = function( userId, tabId, message, done ){

  var tabIdHash = {};

  hotplate.logger.warn("In makeTabIdHashForMultihome!" );

  hotCoreStoreRegistry.getAllStores( function( err, allStores ){
    if( err ){
       next( err );
    } else {

      if( typeof(  allStores[ message.storeName ] ) === 'undefined' ){
        hotplate.logger.log("The message is for an undefined store, skipping comet broadcast: " , message );
        done( null, {} );
        return;
      };

      // Get a list of all tabs
      allStores.tabs.apiGetQuery( { }, function( err, tabs ){
        if( err ){
          done( err );
        } else {

          
          hotplate.logger.log("TABS: " , tabs );

          var hotGlobalBroadcast = allStores[ message.storeName ].hotGlobalBroadcast;

          // CASE #1

          // Global broadcast required: sending it to _every_ tab!

          if( hotGlobalBroadcast ){
            hotplate.logger.log("Global broadcast required! " );

            tabs.forEach( function( tab ){
              if( tab.id != tabId ) tabIdHash[ tab.id ] = true;
            });

            hotplate.logger.log("TABS HASH: " , tabIdHash );
            done( null, tabIdHash );
          } 

          // CASE #2

          // The record HAS a workspaceId: send it to all tabs of users belonging
          // to that specific workspaceId
          else if( typeof( message.object.workspaceId ) !== 'undefined' ){
          
            hotplate.logger.log("YES workspaceId"  );
 
            var uids = {};

            // Get a list of users for that workspace
            allStores.workspacesUsersBase.apiGetQuery( { filters: { workspaceId: message.object.workspaceId } }, function( err, workspacesUsers ){

              workspacesUsers.forEach( function( wu ){
                uids[ wu.userId ] = true;
              });
              
              // Add to tabIdHash any tab that belongs to a "good" user
              tabs.forEach( function( t ){ if( uids[ t.userId ] && t.id != tabId ) tabIdHash[ t.id ] = true; });

              hotplate.logger.log("TABS HASH: " , tabIdHash );

              // That's it!
              done( null, tabIdHash );

            });

          // CASE #3

          // The record DOESN'T HAVE a workspaceId: send it to all tabs of users
          // who are in the same workspace as userId
          } else {

            hotplate.logger.log("NO workspaceId"  );

            var uids = {};


            // CAVEAT 3a: it doesn't have a userId set. This means that this is a server-generated
            // message (no user) on a record without workspace. It will necessarily need to spam
            // all users about the change
            //
            if( userId == null ){
              hotplate.logger.log("No userId (server-generated Json op) and no workspaceId, will broadcast" );

              tabs.forEach( function( tab ){
                if( tab.id != tabId ) tabIdHash[ tab.id ] = true;
              });

              hotplate.logger.log("TABS HASH: " , tabIdHash );
              return done( null, tabIdHash );
            }

            // Get a list of workspaces for the requesting user
            allStores.workspacesUsersBase.apiGetQuery( { filters: { userId: userId } }, function( err, workspacesUsers ){

              if( err ){
                hotplate.logger.log( err );
                return done( err );
              }

              hotplate.logger.log("Workspaces for user ", userId,": ", workspacesUsers );

              workspacesUsers.forEach( function( w ){

                if( err ){
                  return done( err );
                }

                // Get a list of users for that workspace
                allStores.workspacesUsersBase.apiGetQuery( { filters: { workspaceId: w.workspaceId } }, function( err, workspacesUsers ){

                  if( err ){
                    return done( err );
                  }


                  hotplate.logger.log("Users in workspace ", w.id, ": " , workspacesUsers );

                  workspacesUsers.forEach( function( u ){
                    
                    hotplate.logger.log("ADDING UID: " , w.userId );
                    uids[ u.userId ] = true;
                  });

                  hotplate.logger.log("UIDS: " , uids );

                  // Add to tabIdHash any tab that belongs to a "good" user
                  tabs.forEach( function( t ){ if( uids[ t.userId ] && t.id != tabId ) tabIdHash[ t.id ] = true; });

                  hotplate.logger.log("TABS HASH: " , tabIdHash );

                  done( null, tabIdHash );
                });
              });
            });
          }
        }
      });
    }
  });
}


var userInWorkspace = exports.userInWorkspace = function( userId, workspaceId, done ){

  stores.workspacesUsersBase.apiGetQuery( { filters: { userId: userId, workspaceId: workspaceId } }, function( err, docs ){
    if( err ){
      done( err );
    } else {
      done( null, docs.length );
    }
  });

}


/*
  IN SHORT:
  * ALWAYS: User must belong to workspace (workspaceId is checked)
  * To WRITE (putExisting, putNew, post, delete), userId needs to match logged in user
*/
exports.MultiHomeBasicPermissionsMixin = declare( null, {

  _checkWorkspaceId: function( request, cb ){
     var self = this;
 
    if( ! request._req.session.userId ) return cb( new self.UnauthorizedError() );

    if( request.params.workspaceId ){
      userInWorkspace( request._req.session.userId, request.params.workspaceId, function( err, there ){
        if( ! there ){
          cb( null, false );
        } else {
          cb( null, true );
        }
      });
    } else {
      cb( null, true );
    }
  },

  _checkUserIdMultiHome: function( request, cb ){
    var self = this;

    if( ! request._req.session.userId ) return cb( new self.UnauthorizedError() );

    if( request.params.userId ){

      if( request.params.userId.toString() !== request._req.session.userId.toString() ){
        cb( null, false );
      } else {
        cb( null, true );
      }
    } else {
      cb( null, true );
    }
        
  },

  _checkWorkspaceIdAndUserId: function( request, cb ){
    var self = this;

    self._checkWorkspaceId( request, function( err, res ){
      if( err ){
        cb( err );
      } else {
        if( ! res ){
          cb( null, false );
        } else {
         self._checkUserIdMultiHome( request, function( err, res ){
            if( err ){
              cb( err );
            } else {
              cb( null, res );
            }
          });

        }
      }
    });
  },
  checkPermissionsPost: function checkPermissionsPost( request, cb ){
    var self = this;

    this.inheritedAsync( checkPermissionsPost, arguments, function( err, res ){
      if( err ){
        cb( err );
      } else {
        if( ! res ){
          cb( null, false );
        } else {
          self._checkWorkspaceIdAndUserId( request, cb );
        }
      }
    });
  },
  checkPermissionsPutNew: function checkPermissionsPutNew( request, cb ){
    var self = this;

    this.inheritedAsync( checkPermissionsPutNew, arguments, function( err, res ){
      if( err ){
        cb( err );
      } else {
        if( ! res ){
          cb( null, false );
        } else {
          self._checkWorkspaceIdAndUserId( request, cb );
        }
      }
    });
  },
  checkPermissionsPutExisting: function checkPermissionsPutExisting( request, doc, fullDoc, cb ){
    var self = this;

    this.inheritedAsync( checkPermissionsPutExisting, arguments, function( err, res ){
      if( err ){
        cb( err );
      } else {
        if( ! res ){
          cb( null, false );
        } else {
          self._checkWorkspaceIdAndUserId( request, cb );
        }
      }
    });
  },
  checkPermissionsGet: function checkPermissionsGet( request, doc, fullDoc, cb ){
    var self = this;

    this.inheritedAsync( checkPermissionsGet, arguments, function( err, res ){
      if( err ){
        cb( err );
      } else {
        if( ! res ){
          cb( null, false );
        } else {
          self._checkWorkspaceId( request, cb );
        }
      }
    });
  },
  checkPermissionsGetQuery: function checkPermissionsGetQuery( request, cb ){
    var self = this;

    this.inheritedAsync( checkPermissionsGetQuery, arguments, function( err, res ){
      if( err ){
        cb( err );
      } else {
        if( ! res ){
          cb( null, false );
        } else {
          self._checkWorkspaceId( request, cb );
        }
      }
    });
  },
  checkPermissionsDelete: function checkPermissionsDelete( request, doc, fullDoc, cb ){
    var self = this;

    this.inheritedAsync( checkPermissionsDelete, arguments, function( err, res ){
      if( err ){
        cb( err );
      } else {
        if( ! res ){
          cb( null, false );
        } else {
          self._checkWorkspaceIdAndUserId( request, cb );
        }
      }
    });
  },


});


hotplate.hotEvents.on( 'stores', 'hotCoreMultiHome', hotplate.cachable( function( done ){


  hotCoreJsonRestStores.get( function( err, s ){
    if( err ){
      done( err );
    } else {

      var HotStore = s.HotStore;
      var HotSchema = s.HotSchema;

      // ***********************************
      // *** WORKSPACES ********************
      // ***********************************

      var Workspaces = declare( HotStore, {

        schema: new HotSchema({
          workspaceName: { type: 'string', required: true, notEmpty: true, trim: 128, searchable: true,
                           sharedValidator: 'workspaceValidator' },
          ownerUserId:   { type: 'id' }, 
        }),

        storeName:  'workspaces',

        publicURL: '/workspaces/:id',
        hotExpose: true,

        handlePost: true,
        checkPermissionsPost: function( request, cb ){
          // Needs to be logged in
          if( ! request._req.session.userId ) return cb( null, false );
     
          // Make sure that body.ownerUserId IS indeed the logged in user
          request.body.ownerUserId = request._req.session.userId;

          cb( null, true );
        },


        // If creating a new workspace, and the user is logged in, then
        // assign the creating user to that workspace
        afterPost: function( request, doc, fullDoc, cb ){

          if( request.remote && request._req.session.loggedIn ){
            var userId = request._req.session.userId;
            if( userId ){
               // Note: this calls the callback
               stores.workspacesUsers.apiPost( { userId: userId, workspaceId: doc.id }, {}, cb );
            } else {
              cb( null );
            }
          }
        },

      });
      stores.workspaces = new Workspaces();


/*
  var WorkspaceInvites = exports.WorkspaceInvites = declare( HotStore, {

    schema: new HotSchema({
      inviteCode:  { type: 'blob' },
      email     :  { type: 'blob' },
      name      :  { type: 'blob' },
    }),

    handlePost: true,
    handleGet: true,
    handleGetQuery: true,
    handleDelete: true,

    storeName:  'workspaceInvites',
    paramIds: [ 'workspaceId', 'id' ],
    publicURL: '/workspaces/:workspaceId/invites/:id',
  });
*/


      // The basic schema for the WorkspacesUsers table
      var WorkspacesUsersBase = declare( HotStore, {

        schema: new HotSchema({
          userId:      { type: 'id', searchable: true },
          workspaceId: { type: 'id', searchable: true },
        }),

        storeName: 'workspacesUsersBase',
        collectionName: 'WorkspacesUsers',

        paramIds: [ 'id' ],
      });
      stores.workspacesUsersBase = new WorkspacesUsersBase();


      var WorkspacesUsers = declare( WorkspacesUsersBase, {

        onlineSearchSchema: new HotSchema({
          userId:      { type: 'id' },
        }),

        storeName:  'workspacesUsers',
        collectionName: 'workspacesUsers',

        publicURL: '/workspaces/:workspaceId/users/:id',
        hotExpose: true,

        handleGetQuery: true,

        checkPermissionsGetQuery: function( request, cb ){
          userInWorkspace( request._req.session.userId, request.params.workspaceId, cb );
        },

      });
      stores.workspacesUsers = new WorkspacesUsers();

      var UsersWorkspaces = declare( WorkspacesUsersBase, {

        onlineSearchSchema: new HotSchema({
          workspaceId:   { type: 'id' },
        }),

        storeName:  'usersWorkspaces',
        collectionName: 'workspacesUsers',

        publicURL: '/users/:userId/workspaces/:id',
        hotExpose: true,

        handleGetQuery: true,
        checkPermissionsGetQuery: function( request, cb ){
          // Only their own workspaces
          if( request._req.session.userId != request.params.userId ) return cb( null, false );
          cb( null, true );
        },


        // Get the much needed workspaceName from the Workspaces table
        // TODO: CONVERT THIS TO _nested!!
        prepareBeforeSend: function( request, doc, cb ){

          var self = this;

          stores.workspaces.apiGet( doc.workspaceId, {}, function( err, otherDoc ){
            if( err ){
              cb( err );
            } else {
              doc.workspaceName = otherDoc.workspaceName;
              cb( null, doc );
            }
          })

        },
      });
      stores.usersWorkspaces = new UsersWorkspaces();

      done( null,  stores );

    }
  })


}));



// Place relevant config variables on the rendered page
hotplate.hotEvents.on( 'pageElements', 'hotCoreMultiHome', function( done ){

  done( null, {
    vars:  [
             { name: 'enabled',      value: hotplate.config.get('hotCoreMultiHome.enabled') },
             { name: 'multiHomeURL', value: hotplate.config.get('hotCoreMultiHome.multiHomeURL') },
           ],
  });
});

// Place workspaceId on the rendered page
hotplate.hotEvents.on( 'pageElementsPerPage', 'hotCoreMultiHome', function( req, pageName, done ){

  var vars = [];

  // Add the user ID to the page as a variable
  if( req.params.workspaceId ){
    vars.push( { name: 'workspaceId', value: req.params.workspaceId } );
  }

  done( null, {
    vars: vars
  });

});

