"use strict";

var dummy
  , hotplate =  require('hotplate')
  , declare = require( 'simpledeclare' )
  , SimpleDbLayer = require( 'simpledblayer' )
  , SimpleSchema = require( 'simpleschema' )
  , JsonRestStores = require( 'jsonreststores' )

  , hotCoreStoreRegistry = require('hotCoreStoreRegistry')
  , hotCoreMultiHome = require('hotCoreMultiHome')
  , hotCoreServerLogger = require( 'hotCoreServerLogger' )
;

exports.get = function( done ){

  var classes = {};
  var sharedValidators = {};

  hotplate.hotEvents.emit('sharedFunctions', function( err, sharedFunctions) {
    if( err ){
      done( err );
    } else {

      // Gets the results, and adds them to the sharedValidators hash which
      // will then get used
      sharedFunctions.onlyResults().forEach( function( functions ){
        for( var k in functions ){
          // If it ends with "Validator", then it's a validator
          if( k.indexOf('Validator', k.length - 'Validator'.length) !== -1 ){
            sharedValidators[ k ] = functions[ k ];
          }
        }
      });

      classes.HotSchemaMixin = declare( null, {

        sharedValidatorTypeParam: function( p ){
          if( typeof( p.parameterValue ) !== 'string' )
            throw( new Error("Validator needs to be a string, found: " + typeof( p.parameterValue ) ) );

     
          var f = sharedValidators[ p.parameterValue + "Validator" ];
 
          if( f && ! f( p.value ) ){
            var msg = f( false );
            p.errors.push( { field: p.fieldName, message: msg, mustChange: true } );
          }
        }
      });

      // Basic schema with info defined in config
      classes.BasicSchema = declare( [ SimpleSchema, hotplate.config.get( 'hotplate.SchemaMixin') ] );

      // Advanced schema mixin with validators
      classes.HotSchema = declare( [ classes.BasicSchema, classes.HotSchemaMixin ] );


      classes.HotStoreMixin = declare( null, {

        killComet: false,
        chainErrors: 'all',

        hotGlobalBroadcast: false,

        echoAfterPutNew: true,
        echoAfterPutExisting: true,
        echoAfterPost: true,

        logError: function( error ){
          hotCoreServerLogger.log( error );
        },

        _getTabId: function( req ){

          // If the tab header wasn't there, then there is no way to broadcast -- abord
          if( typeof( req ) === 'undefined' ) return null;

          var tabId = req.headers['x-hotplate-tabid'];
          if( tabId == '' ){
            tabId = null;
          }
          return tabId; 
        },


        _broadcast: function( request, type, objectId, object, cb ){

          var makeTabIdHash;
          var fromUserId;
          var storeTarget;

          // No comet required (from the option, or for the store's own request
          if( this.killComet || request.killComet ) return;

          // fromUserId taken from the session (if it exists) or set to null (it's an API call)
          fromUserId = ( request._req && request._req.session && request._req.session.userId ) || null;

          // If it's in a multi-home environment, use the specific multi-home filter
          // if( hotplate.config.get( 'hotCoreMultiHome.enabled' ) && object.workspaceId ) makeTabIdHash = exports.makeTabIdHashForMultihome;
          if( hotplate.config.get( 'hotCoreMultiHome.enabled' ) ) makeTabIdHash = hotCoreMultiHome.makeTabIdHashForMultihome;

          var message = { type: type, storeName: this.storeName, objectId: objectId, object: object };

          // If options.beforeId is set, make up a fake record with 'before' set as record with matching ID is idProperty
          // We cannot really send the whole record as we never fetch it fully
          if( request.options.beforeId ){
            if( request.options.beforeId === 'null' ){
              message.before = null;
            } else {
              message.before = {};
              message.before[ this.idProperty ] = request.options.beforeId;
            }
          }
          if( request.options.justReposition) message.justReposition = true;

          // Actually invoke the broadcast
          hotplate.hotEvents.emit('cometBroadcast', fromUserId, this._getTabId( request._req ), makeTabIdHash, message, cb );


          /*
            // What follows is the attempt to send a comet message for every store that uses the _collection_ modified by the
            // change. Unfortunately, sub-stores that change a subset of the data effectively cannot be done because
            // the comet message would be incomplete (it would only have some of the fields).


          hotCoreStoreRegistry.getAllStores( function( err, allStores ){


            allStores.collections[ self.collectionName ].forEach( function( s ){

              console.log("Setting up a message for ", s.storeObject.storeName );
              var message = { type: type, storeName: s.storeObject.storeName, objectId: objectId, object: object };
              console.log("The message is: ", message );

              // If options.beforeId is set, make up a fake record with 'before' set as record with matching ID is idProperty
              // We cannot really send the whole record as we never fetch it fully
              if( options.beforeId ){
                if( options.beforeId === 'null' ){
                  message.before = null;
                } else {
                  message.before = {};
                  message.before[ this.idProperty ] = options.beforeId;
                }
              }
              if( options.justReposition) message.justReposition = true;

              // Actually invoke the broadcast
              hotplate.hotEvents.emit('cometBroadcast', fromUserId, self._getTabId(), makeTabIdHash, message,  function(){}  );

            });

          } );
          */


        },

        afterPutExisting: function afterPutExisting( request, doc, fullDoc, docAfter, fullDocAfter, overwrite, done){
          var self = this;

          this.inheritedAsync( afterPutExisting, arguments, function(){
            self._broadcast( request, 'storeRecordUpdate', docAfter[ self.idProperty], docAfter, done );
          });
        },    

        afterPost: function afterPost( request, doc, fullDoc, done ){
          var self = this;
          this.inheritedAsync( afterPost, arguments, function(){
            self._broadcast( request, 'storeRecordCreate', doc[ self.idProperty], doc, done );
          });
        },

        afterPutNew: function afterPutNew( request, doc, fullDoc, overwrite, done ){
          var self = this;
          this.inheritedAsync( afterPutNew, arguments, function(){
            self._broadcast( request, 'storeRecordCreate', doc[ self.idProperty], doc, done );
          });
        },

        afterDelete: function afterDelete( request, doc, fullDoc, done ){
          var self = this;
          this.inheritedAsync( afterDelete, arguments, function(){
            self._broadcast( request, 'storeRecordRemove', doc[ self.idProperty ], doc, done ); 
          });
        },    
      });


      // Sets the DB Layer
      var DbLayer = declare([ SimpleDbLayer, hotplate.config.get('hotplate.DbLayerMixin') ], {
        db: hotplate.config.get( 'hotplate.db' ) 
      });

      // Creates a basic DB store based on that layer
      classes.BasicDbStore = declare( JsonRestStores, {
        DbLayer: DbLayer,
      });

      // Creates the HotStore: the basic DB store with HotStoreMixin
      classes.HotStore = declare( [ classes.BasicDbStore, classes.HotStoreMixin ]);

      done( null, classes );

    }
  });

}


/*
  IN SHORT:
  * To WRITE (putExisting, putNew, post, delete), userId needs to match logged in user
*/
exports.BasicPermissionsMixin = declare( null, {

  _checkUserId: function( request, cb ){
    if( request.params.userId ){

      if( ! self._req.session.userId ) return cb( new self.UnauthorizedError() );

      if( request.params.userId.toString() !== request._req.session.userId ){
        cb( null, false );
      } else {
        cb( null, true );
      }
    } else {
      cb( null, true );
    }
        
  },

  checkPermissionsPost: function checkPermissionsPost( request, cb ){
    var self = this;

    this.inheritedAsync( checkPermissionsPost, arguments, function( err, res ){
      if( err ){
        cb( err );
      } else {
        if( ! res ){
          cb( null, false );
        } else {
          self._checkUserId( request, cb );
        }
      }
    });
  },
  checkPermissionsPutNew: function checkPermissionsPutNew( request, cb ){
    var self = this;

    this.inheritedAsync( checkPermissionsPutNew, arguments, function( err, res ){
      if( err ){
        cb( err );
      } else {
        if( ! res ){
          cb( null, false );
        } else {
          self._checkUserId( request, cb );
        }
      }
    });
  },
  checkPermissionsPutExisting: function checkPermissionsPutExisting( request, doc, fullDoc, cb ){
    var self = this;

    this.inheritedAsync( checkPermissionsPutExisting, arguments, function( err, res ){
      if( err ){
        cb( err );
      } else {
        if( ! res ){
          cb( null, false );
        } else {
          self._checkUserId( request, cb );
        }
      }
    });
  },
  checkPermissionsDelete: function checkPermissionsDelete( request, doc, fullDoc, cb ){
    var self = this;

    this.inheritedAsync( checkPermissionsDelete, arguments, function( err, res ){
      if( err ){
        cb( err );
      } else {
        if( ! res ){
          cb( null, false );
        } else {
          self._checkUserId( request, cb );
        }
      }
    });
  },


});

/*
  IN SHORT:
  * To READ (get, getQuery), userId needs to match logged in user
*/
exports.PrivateUserDataPermissionsMixin = declare( null, {

  _checkUserIdForJsonRestStores: function( request, cb ){
    var self = this;

    if( ! request._req.session.userId ) return cb( new self.UnauthorizedError() );

    if( request.params.userId ){

      if( request.params.userId.toString() !== request._req.session.userId.toString() ){
        cb( null, false );
      } else {
        cb( null, true );
      }
    } else {
      cb( null, true );
    }
        
  },

  checkPermissionsGet: function checkPermissionsGet( request, doc, fullDoc, cb ){
    var self = this;

    this.inheritedAsync( checkPermissionsGet, arguments, function( err, res ){
      if( err ){
        cb( err );
      } else {
        if( ! res ){
          cb( null, false );
        } else {
          self._checkUserIdForJsonRestStores( request, cb );
        }
      }
    });
  },
  checkPermissionsGetQuery: function checkPermissionsGetQuery( request, cb ){
    var self = this;

    this.inheritedAsync( checkPermissionsGetQuery, arguments, function( err, res ){
      if( err ){
        cb( err );
      } else {
        if( ! res ){
          cb( null, false );
        } else {
          self._checkUserIdForJsonRestStores( request, cb );
        }
      }
    });
  },
 
});



