/*
  For curiosity: wait for what mailing list says about:
  http://dojo-toolkit.33424.n3.nabble.com/Calculating-widget-sizes-before-they-are-displayed-td3988031.html
*/

define([
  'dojo/_base/declare',
  'dojo/_base/window',
  'dojo/_base/fx',
  'dojo/fx',
  'dojo/_base/array',
  'dojo/dom',
  'dojo/dom-attr',
  'dojo/dom-class',
  'dojo/dom-style',
  'dojo/dom-construct',
  'dojo/dom-geometry',
  'dojo/cookie',
  'dojo/_base/kernel',
  'dojo/_base/lang',
  'dojo/has',
  'dojo/on',

  'dijit/_WidgetBase',
  'dijit/_TemplatedMixin',

  ], 
  function(
  declare
  , win
  , baseFx
  , fx
  , array
  , dom
  , domAttr
  , domClass
  , domStyle
  , domConstruct
  , domGeometry
  , cookie
  , dojo
  , lang
  , has
  , on

  , _WidgetBase
  , _TemplatedMixin
){

return declare("hotplate.hotDojoWidgets.AlertBar", [_WidgetBase, _TemplatedMixin], {

  isShown: false,

  // message:string
  //    The message shown when the widget is on
  message: "", 

  //  buttonCancel:String
  //    The HTML tip show when hovering over the close button.
  closeText:"Close",

  //  dontRemindButton:String
  //    The text link shown that when clicked, permanently dismisses
  //    the message (sets a cookie). If this string is blank, this
  //    link is not displayed.
  dontRemindText:"",

  templateString: '' +
    '<div class="dojoxAlertBar">' +
    '  <div class="dojoxAlertBarMessage" dojoAttachPoint="messageNode">${message}</div>'+
    '  <div class="dojoxAlertBarReminderLink" dojoAttachPoint="dontRemindButtonNode" dojoAttachEvent="onclick:_onDontRemindClick">${dontRemindText}</div>' +
    '  <span dojoAttachPoint="closeButtonNode" class="dojoxAlertBarCloseIcon" dojoAttachEvent="onclick: hide, onmouseenter: _onCloseEnter, onmouseleave: _onCloseLeave" title="${closeText}"></span>'+
    '</div>' +
    '',

  // calculates the height parameter. It will only calculate it if
  // 1) It's not already calculated
  // 2) The widget is not being displayed
  _calculateHeight: function(){

    // Get the previous display style
    var prevDisplay = domStyle.get(this.domNode, 'display');

    // Set to "block" so that it's visible, and calculate height
    domStyle.set(this.domNode, "display", "block");
    var newHeight =  domGeometry.getContentBox(this.domNode).h;

    // Set the new height IF a new height came back.
    this._height = newHeight || this._height || 0;

    // Restore old display type (it could be hidden)
    domStyle.set(this.domNode, "display", prevDisplay );
  },

  constructor: function(props, srcNode){


    // displayCondition has been passed: now it's just a string, needs to turn into a function 
    // evaluating the original condition
    if( typeof(props.displayCondition) === 'string' ){

      // Get the original display condition into a variable in
      // the constructor's scope. Will be used to create the eval
      var originalCondition = props.displayCondition;

      // If something was passed in the template, the user probably wants to
      // display this as soon as it starts up
      this._displayAtPostCreate = true;

      props.displayCondition = function(){
        // the function that fires to determine if the
        // bar shows or not.
        var evals = true;
        try{
          evals = dojo.eval(originalCondition);
        } catch(e){ }
        return evals; 
      } 
    }

    // Safe mixin passed properties (included possibly 'augmented' displayCondition
    declare.safeMixin(this, props);

    // FIXME: here for debugging purposes 
    // ALERT.push(this);
  },


  postCreate: function(){
    this.inherited(arguments);

    // Make it invisible. "invisible" always needs to be the starting point
    domStyle.set(this.domNode, "display", "none");
    
    // If displayCondition is set in the template, then _displayAtPostCreate will be
    // true -- the widget will _attempt_ to display (although it will depend on the
    // condition set by the user!)
    //
    if( this._displayAtPostCreate ){
      this.show(this.initialTimeout);
    }
  
  },

  // By default, the displayCondition is set to true.
  // This can be redefined programmatically, or
  // it can be defined by data-dojo-props="displayCondition='1 == 0'" (which will be
  // turned into a working displayCondition function running the eval
  displayCondition: function(){
    return true;
  }, 


  show: function(timeout, force){

    //  summary:
    //    Shows the bar. Do not call directly.
    //    Use notify();
    // tags:
    //    private
    //

    // In the future, I could do this instead of throwing an exception
    // (this code would also get the size?)
    //if(!this.domNode.parentNode || !this.domNode.parentNode.innerHTML){
    //  document.body.appendChild(this.domNode);
    //}

    // Sets the timeout to close it if "timeout" was passed
    if(timeout){
      setTimeout( lang.hitch( this, function(){
         this.hide();
      }), timeout );
    }

  
    // If it wasn't "forced" and displayCondition is false, then don't do anything
    if( ! force  && !this.displayCondition() ){
      return;
    }

    // It's already showing: nothing to do
    if(this.isShown){
      return;
    }

    // It was disabled for life: don't show
    if( cookie("disableAlertForever."+this.id)){
      return;
    }

    // There is nothing to show: nothing to do here
    if(this.message == ''){
      return;
    }

    // Calculate the height the widget will be pushed at
    this._calculateHeight();

    // From now on, it will be showing
    this.isShown = true;

    
    // Get the body's top margin, which will be increased by the widget size after the hide
    // var bodyMarginTop = domStyle.get(win.body(), "marginTop");

    // Actually shows the bar (that is: sets height:this._height, opacity:1 and display:block)
    // At the end, it will set height to 100%, the "home" value,  so that the widget will adjust 
    // if needed (e.g. message size grows in real time, etc.)
    // 
    if( ! this._showAnim){
      domStyle.set(this.domNode, { display:"block", height:0, opacity:0 });
      this._showAnim = fx.combine([
        //baseFx.animateProperty({ node:win.body(), duration:500, properties:{ marginTop: bodyMarginTop+this._height } }),
        baseFx.animateProperty({ node:this.domNode, duration:500, properties:{ height:this._height, opacity:1 } })
       ]);
 
      // At the end of the animation
      this._showAnim.onEnd = lang.hitch(this, function(){
        this._showAnim = null;
        domStyle.set(this.domNode, "height", 'auto' ); // MERC: Was "100%"
      });
      this._showAnim.play();
    }
  },



  hide: function(){

    // It's not showing: nothing to hide
    if(!this.isShown){
      return;
    }
    // From now on, it will be hiding
    this.isShown = false;

    // Get the body's top margin, which will be shrunk by the widget size after the hide
    // var bodyMarginTop = domStyle.get(win.body(), "marginTop");

    // Actually hides the bar (that is: sets height:0, opacity:0 and display:none)
    //
    if(!this._hideAnim){
      this._hideAnim = fx.combine([
         //baseFx.animateProperty({ node:win.body(), duration:500, properties:{ marginTop: bodyMarginTop-this._height } }),
         baseFx.animateProperty({ node:this.domNode, duration:500, properties:{ height:0, opacity:0 } })
      ]);
 
      // Temporary: see:
      // http://dojo-toolkit.33424.n3.nabble.com/fx-combine-is-not-an-event-emitter-on-won-t-work-td3987666.html
      // Should be:
      // on(this._hideAnim, "End", lang.hitch(this, function(){
      // WAS:
      //  dojo.connect(this._hideAnim, "onEnd", this, function(){
      this._hideAnim.onEnd = lang.hitch(this, function(){
        domStyle.set(this.domNode, "display", "none");
        domStyle.set(this.domNode, "height", 'auto' ); // MERC: WAS 100%
        this._hideAnim = null;
      });
      //}));
      this._hideAnim.play();
    } 

  },

  _onDontRemindClick: function(){
    // summary:
    //    Called when user clicks the "do not remind" link.
    // tags:
    //    private
    // FIXME
    cookie("disableAlertForever."+this.id, true, { expires:3650 });
    this.hide();
  },


  ///////////////////////////////////
  // ATTRIBUTES
  // Not using shorthand as I don't
  // know yet where this is going
  ///////////////////////////////////

  _setMessageAttr: function(v){
    this._set('message', v);
    this.messageNode.innerHTML = v;

    // The height might have changed, recalculate it
    this._calculateHeight();
  },
  _getMessageAttr: function(){
    return this.message;
  },
  _setCloseTextAttr: function(v){
    this._set('closeText', v);
    domAttr.set(this.closeButtonNode, {title: v}  );
  },
  _getCloseTextAttr: function(){
    return this.closeText;
  },
  _setDontRemindTextAttr: function(v){
    this._set('dontRemindText', v);
    this.dontRemindButtonNode.innerHTML = v;
  },
  _getDontRemindTextAttr: function(){
    return this.dontRemindText;
  },

  _setBackgroundAttr: function(v){
    this._set('background', v);
    domStyle.set(this.domNode, 'background', v);
  },
  _getBackgroundAttr: function(){
    return this.background;
  },


  ///////////////////////////////////
  // Just fancy visual effects
  ///////////////////////////////////

  _onCloseEnter: function(){
    // summary:
    //    Called when user hovers over close icon
    // tags:
    //    private
    domClass.add(this.closeButtonNode, "dojoxAlertBarCloseIcon-hover");
  },

  _onCloseLeave: function(){
    // summary:
    //    Called when user stops hovering over close icon
    // tags:
    //    private
    domClass.remove(this.closeButtonNode, "dojoxAlertBarCloseIcon-hover");
  },

  resize: function(){
    this.inherited(arguments);
  },


  })

});
