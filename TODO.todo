✔ server @done(2020-08-21 07:13)
  ✔ write initial server (server directory, change 'start' in main package.json) @done(2020-08-19 07:55)
  ✔ Make sure basic open-wc app runs @done(2020-08-19 07:56)
  ✔ Add DB/session/serverstores module with prompts questions for DB setup @done(2020-08-20 09:35)
  ✔ Exit everything on ctrl-c on input (prompts) @done(2020-08-21 07:05)
✔ Change the way initial setup works @done(2020-08-21 07:34)
  ✔ Two lists: one of "super-packages", and one of "optional ones" (set in package.json) @done(2020-08-21 06:45)
  ✔ Allow multi-select for optional ones @done(2020-08-21 07:05)
  ✔ Allow positioning of modules (position field in package.json) @done(2020-08-21 07:05)
  ✔ Make it possible to add multiple modules via cmd (commander) and UI @done(2020-08-21 07:12)
  ✔ Blank out already installed packages @done(2020-08-21 07:34)
✔ Add basic client module, working with or without open-wc (tpe app with tabs) @done(2020-08-22 21:22)
  ✔ Add "fs" key to module, for file system changes, before-manipulate and after-manipulate, with ops and parameters (rename) @done(2020-08-23 07:29)
✔ Add new type of reinstallable module, for pages etc. @done(2020-12-21 20:21)
✔ Change json to json5, in order to being able to add comments -- CHANGE OF HEART @done(2020-12-27 21:07)
✔ Change "// *** -- start" into self-contained blocks /* */ @done(2020-12-28 06:38)
✔ Change PageElementMixin render function @done(21-01-04 17:23)
✔ Add more gathered metainfo (Mixin, title, whatever) with regex from findAnchorPoints  @done(2021-01-07 16:46)
✔ Have a function that will display that info as as sentence @done(2021-01-07 16:46)
✔ Add extra sentence to prompts, and write little intro when placing element @done(2021-01-07 16:46)
✔ Rename client-app-add-tabs into client-app-element-tabs @done(2021-01-07 16:46)
✔ Create client-app-add-page-tabs @done(2021-01-07 16:46)
✔ Complete placement of client-app-element with prompts @done(2021-01-07 16:46)
✔ Write client-app-inner-page so that it places inner pages in right spot @done(2021-01-07 16:46)
✔ Work out how to add a page either in Page Insertion Point or Page tab insertion point @done(2021-01-08 07:43)
✔ Work out how to add an element either in Element Insertion Point or Element tab insertion point @done(2021-01-08 07:43)
  ✔ HINT: write textManipulation as a function, AND findAnchorPoints() given an array, and adding anchor point to info @done(2021-01-08 07:43)
✔ REWORK things so that postAdd is not used for extra prompts, use prepRompts instead (doh) @done(2021-01-09 10:49)
✔ Finish client-app-inner-pages @done(2021-01-09 15:34)
  ✔ Add URL info to js-kit/utils/getFileInfo @done(2021-01-09 11:27)
  ✔ Ask for path RELATIVE to the path above @done(2021-01-09 11:27)
✔ Split findAnchorPoints so that there is a generic one from scaffoldizer and a specific super-short one for js-kit @done(2021-01-10 06:06)
✔ Harmonise API so that config is always at the beginning @done(2021-01-10 06:37)
✔ Allow to add elements in a "elements" subdirectory under the element itself @done(2021-01-10 09:03)
✔ Check that element doesn't exist already @done(2021-01-10 10:43)
✔ Check that element path is not already set @done(2021-01-10 11:47)
✔ Force names for add/list/view elements @done(2021-01-12 07:58)
✔ Check that it still all works (and check headers are off in inner-pages) @done(2021-01-12 11:06)
  ✔ routed-element (cloned from inner-page, adding a 'routedElement' element to the tab) @done(2021-01-13 06:28)
  ✔ NOT DONE - inner-page (as is, but taking tab placement out) @done(2021-01-13 06:45)
  ✔ add-element-tabs -- (renaming add-tabs). NOTE: app-element will add to it @done(2021-01-13 06:10)
  ✔ add-routed-element-tabs (renaming add-page-tabs, normal ee-tab but "passive") @done(2021-01-13 06:45)
  ✔ NOT DONE add-routed-element-stack? (future) @done(2021-01-13 06:47)
✔ Make js-kit work as a standalone program @done(2021-01-14 07:44)
✔ Change order of parameters is stock scaffoldizer https://stackoverflow.com/questions/4351521/how-do-i-pass-command-line-arguments-to-a-node-js-program @done(2021-01-15 08:44)
✔ Add eslint to frame @done(2021-01-15 09:17)
✔ Make sure it still works if app name doesn't have a "-" by adding 'main' @done(2021-01-15 10:13)
✔ Make sure that result app is fully linted @done(2021-01-15 13:21)
✔ Add full hooks (same as plain-PREFIX-ELEMENTNAME) to PREFIX-landing, PREFIX-load-error, PREFIX-not-found @done(2021-01-16 09:39)
  ✔ Done programmatically! (Was: Could this be done programmatically? @done(2021-01-16 09:39)
✔ Add server stores (server-store) (simple version) @done(2021-01-17 11:14)
  ✔ Validate store name, ensure there is no matching store @done(2021-01-17 22:39)
  ✔ Validate store URL, ensure there is no matching URL @done(2021-01-17 22:39)
  ✔ Validate version better @done(2021-01-17 23:13)
  ✔ Improve error message so that findMatchingStoreNameAndVersions gives list of versions @done(2021-01-18 07:47)
  ✔ Turn choices into a select @done(2021-01-18 07:57)
  ✔ Add default version value to server stores @done(2021-01-18 08:16)
✔ Add DB server stores (server-db-store) (simple version) @done(2021-01-18 09:48)
✔ Add way to run scripts -- use to create databases (picking store) @done(2021-01-18 11:54)
✔ Check that DB sync actually works @done(2021-01-18 23:31)
  ✔ Reset project @done(2021-01-18 22:29)
  ✔ Create database @done(2021-01-18 22:29)
  ✔ Add DB credentials that actually connect to a DB @done(2021-01-18 22:29)
  ✔ Run server and check that DB connection is happening @done(2021-01-18 23:31)
  ✔ Check that sync script actually does run @done(2021-01-18 23:31)
✔ Write function that, given a store and version, returns a list of fields and types @done(2021-01-18 23:49)
✔ Make AddEdit work <nn-input-text dense name="voucherNumber" label="V#" .value=${this.data.voucherNumber || ''} > </nn-input-text> @done(2021-01-27 06:15)


☐ NOTES ON STORES
Companies
  /companies/:id
People [FK: companyId]
  /people/:id
  /companies/:companyId/people/:id
Addresses [FK: personId]
  /addresses/:id
  /people/:personId/addresses/:id

☐ Add parameters to anchorPoints. Will need it for "useItem"
☐ When in a list element, in the main cycle have an element insertion point, with parameter "useItem"
☐ Always pass "data" to child
☐ In listElement, make the anchor within the map() cycle with (useItem=true)

NOTE:
**URL PARAMS ARE ONLY FOR LOADING**
Routing/Page Elements will have a property `reloadFromLocation` used in routerCallback

Non-list elements will have an internal storeParams variable which will either be set in routerCallback() or in updated('data').
  - E.g. <view-element .data=${this.data}> (AppElement) or <view-element> (Routing/Page Elements)
  - getStoreUrl() will always use storeParams.* to make up the URL. E.g. return `/stores/people/${this.storeParams.id}`
  - For AppElement elements, .data MUST be provided since they cannot load it themselves
  - For Routed/Page elements, .data is optional (it will be loaded unless reloadFromLocation is false)

List elements will have an internal storeParams variable which will either be set in routerCallback() or passed to it directly
  - E.g. <list-element .data=${this.(item||data).ports} .storeParams=${this.(item||data)}> or <list-element>
  - getStoreUrl() will always use storeParams.* to make up the URL. E.g. return `/stores/people?companyId=${this.storeParams.id}`
  - For AppElement elements, .data MUST be provided since they cannot load it themselves
  - For Routed/Page elements, .data is optional (it will be loaded unless reloadFromLocation is false)
  - storeParams is NEVER guaranteed to be a full record. If used in Routed/Page elements, it will only contain the IDs from the URL. A ListElement
    that has listed items that need data in the parent record will need to be contained into a ViewElement which will load it and pass it along

This means that list elements will always have access to the crucial filtering IDs they need to fetch/save the correct data. Fetching is important EVEN
when having the data available and preloaded, in case the user wants to change ordering fields, go to next page if available, etc.


☐ NOTES
  ✔ AddEdit is done @done(2021-01-27 06:15)
  ✔ Change renderAddEditElement so that it's a function that includes an argument with the actual form, NO MORE innerRender @done(2021-01-27 06:15)
  ✔ Rename 'edit' into 'add-edit' everywhere @done(2021-01-27 06:51)
  ✔ Make it select the store @done(2021-01-27 08:01)
  ✔ Decide how NOT to ask for store elements if no stores added, maybe check if module is installed @done(2021-01-27 08:58)
  ☐ Look for "message: 'Which" and change function to call pageTypeQuestion()
  ☐ Make it work out the fields by actually loading the store
  ☐ Add the fields in add-edit
  ☐ MAYBE make add, edit, add-edit pages rather than blanket "add" (only URL is different?).
  ☐ AddEdit now works for root pages, replicate the same thing for other pages
  ☐ Add save/cancel button to app header

☐ (With Raphael) Add edit/list/view elements (client-app-element, client-app-root-page, client-app-routed-element)
  ☐ Decide how to add buttons to page from contained element
  ☐ Final decision on "currentParams" etc.
    ☐ Have AddEditCommonMixin.js which includes StoreAddEditMixin AND a renderAddEdit() function (with hte current render())
    ☐ AddEditPageElement.js inherits from PageElement mixed with AddEditMixin.js
    ☐ AddEditElement.js inherits from AppElement mixed with AddEditElement.js
    ☐ The difference between AddEditPageElement and AddEditElement is in the UI side of things (ADD), plus reloading with params, etc.

☐ (With Raphael) Decide what to do for initial default tabs
☐ --- STAGE 2 DONE ---
☐ client-reducs
☐ clientserver-auth
☐ clientserver-user-config
☐ clientserver-app-config
☐ Look for a different server to serve files rather than open-wc's https://www.npmjs.com/package/es6-module-server
--- STAGE 3 DONE
☐ Document the lot as literate code
☐ Add initial docco-next documentation generation to js-kit
☐ --- STAGE 4 DONE
☐ Maybe add reflect:true to routify's PageElementMixin
☐ Watchout, taken autoload out of PageElementMixin
☐ Add module to build (rollup config)


Testing:
rm -rf testing-app;cp -pr testing-app.START testing-app; node Development/scaffoldizer/bin/scaffoldizer add Development/js-kit testing-app


rm -rf testing-app;cp -pr testing-app.START testing-app; rm -rf testing-app/node_modules; rm -rf testing-app/server/node_modules;node Development/scaffoldizer/bin/scaffoldizer add Development/js-kit testing-app everything; cd testing-app; npm install;cd ..





EVERYTHING BELOW THIS LINE NEEDS TO BE ADJUSTED



NOTE: The difference between an App element and a Routed/Page element is that a Routed/Page element will call reload() if URL has changed. SO, if
an element is not routed, it will need the data passed to it by the parent

Case 1 -- an PageElement co-view-companies which includes a RoutedElement co-list-companies-people. The PageElement loads the
company data first. Then the co-list-companies-people loads the list of people from the company and displays it.
co-list-companies-people MAY be passed parentData which includes the company info
*NOTE: Elements are contained into one-another. If network fails in the parent, it will be apparent and reload-able
*NOTE 2: In this example, there will be one query for the company, and then one query in People for each displayed company,
AND THEN another query un Addresses for each displayed person.
*NOTE 3: if there is no matched ID in store, it will need to be a queryString by default instead of using the URL

*NOTE 4: If the element is changed into AppElement, no autoload will be done. In that case, "data" MUST be passed by
parent

  A COMPANY
    PageElement (view)
    URL: /view-companies/:id
    Element: co-view-companies
    File: /pages/co-view-companies.js
    Store: companies. Match /view-companies/:id with /companies/:id MATCH: id
    Query: /companies/:[storeParams.id] (UI: match URL's "id" with one of the foreign keys in store People)
    Data: "data" (company's record)
    NOTE: storeParams comes either by the URL (if set, for page elements) or from storeParams which is copied from data


  LIST OF PEOPLE FOR A COMPANY
    RoutedElement (list) WITHIN parent co-view-companies
    NOT URL: /view-companies/:id
    Element: co-list-people
    File: /pages/co-view-companies/elements/co-list-people.js
    Store: people.
    Query: /people?companyId=[storeParams.id] (UI: match URL's "id" with one of the foreign keys in store People)
    Data: "data" (list of all people)
    Props...
      MAYBE parentData (co-view-companies.js calls <co-list-people .parentData="${this.data}") -- this.data is the company info
      MAYBE data (co-view-companies.js calls <co-list-people .data="${this.data.people}") -- this.data.people is the list of people

IMPORTANT REMEMBER: storeParams can be set at every data change, so that it includes all the fields defined as ID in the schema

When this element is created, each row is empty, but with a placeholder to add elements.
Each element could be

  A PERSON WITHIN THE LIST OF PEOPLE FOR A COMPANY
    RoutedElement (view) WITHIN parent co-list-people
    URL: /view-companies/:companyId/people/:personId
    Element: co-view-person
    File: /pages/co-view-companies/elements/co-list-people/elements/co-view-person.js
    Store: people
    Query:/addresses?personId=[storeParams.personId] (UI: ask to match URL's "companyId" and "personId" with foreign keys in addresses, ONLY match personId)
    Props...
      MAYBE parentData (co-list-people.js calls <co-view-person .parentData="${this.data}") (this.data is the full list of people)
      MAYBE data (from co-list-people, which calls <co-view-person .data="${item}")
      MAYBE item (from co-list-people, which calls <co-view-person .item="${item}")
      *NOTE: Needs to find a way to do this. Note that "data" and "item" are the same because this is a view element

  RoutedElement (list) WITHIN parent co-list-people
    URL: /view-companies/:companyId/people/:personId/addresses
    Element: co-list-addresses
    File: /pages/co-view-companies/elements/co-list-people/elements/co-list-addresses.js
    Store: addresses
    Query:/addresses?personId=[params.personId] (UI: ask to match URL's "companyId" and "personId" with foreign keys in addresses, ONLY match personId)
    Props...
      MAYBE parentData (co-list-people.js calls <co-list-addresses .parentData="${this.data}") (this.data is the full list of people)
      MAYBE data (from co-list-people, which calls <co-list-addresses .data="${item.addresses}")
      MAYBE item (from co-list-people, which calls <co-list-addresses .item="${item}")

    *NOTE: Needs to find a way to do this. Note that ".addresses", which is a crucial part


IMPORTANT REMEMBER: MUST find a way so that the storeParams object is either set by routerCallback (depending on the change of URL) or by parent
ALSO IMPORTANT: Do not base reloads on change of store URL



Case 2 -- a PageElement that manages the URL all on its own. E.g. /ports/:portId/berths

Case 2A -- An AppElement which contains a RoutedElement (View) to view the port information,
and another RoutedElement (List) to view the list of berths
NOTE: The list element has no access to port information.

  PageElement (plain)
    URL: /ports/:id
    Element: co-port
    File: /pages/co-port.js

  RoutedElement (view) WITHIN parent co-port.
    URL: /ports/:id
    Element: co-view-port.js
    File: /pages/co-port/elements/co-view-port.js
    Store: ports. Match /ports/:id (page) with /ports/:id (store)

  RoutedElement (list) WITHIN parent co-port
    URL: /ports/:id
    Element: co-list-port-berths.js
    File: /pages/co-port/elements/co-list-port-berths.js
    Store: berths. Match with ports/:id (page) with /berths?portId=XXX




**TODO**
  PageElement
    URL: /view-companies/:id
    Element: co-view-companies
    File: /pages/co-view-companies.js
    Store: companies. Match /view-companies/:id with /companies/:id MATCH: id
